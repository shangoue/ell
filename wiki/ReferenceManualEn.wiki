#labels Phase-Implementation,Phase-Design
<wiki:toc max_depth="3" />

= libELL Reference Manual =

This library is written for quick developpement of LL(n) parsers, or other kind of [http://en.wikipedia.org/wiki/EBNF EBNF]-guided C++ applications.

It allows to write EBNF grammars in an executable manner, directly as C++ code.

== The grammar ==

=== Grammar building basis ===

First of all, you will need to be familier to [http://en.wikipedia.org/wiki/EBNF EBNF grammars]. To sum up, EBNF is Backus Naur Form extended to allow the use of regular expression operators.

Let's take the basic grammar which defines how our mathematic expressions works :

{{{
  factor     : "(" expression ")" | INTEGER
  term       : factor ('*' factor | '/' factor) *
  expression : term ('+' term | '-' term) *
}}}


We will now try to write this grammar simply as C++ code.

The definition of each non-terminal (called rule of the grammar) can be represented by an Abstract Syntax Tree, for exemple for the rule `factor`:

{{{
              factor
             /      \
           "("     INTEGER
           /
       expression
         /
       ")"
}}}

In this tree nodes `INTEGER` and `(` are primitives. To the contrary the node `expression` is a link to another tree. Thus, the whole grammar can be represented by a graph.

The C++ code of the grammar will build this syntactic graph in memory. The parser will walk through this graph trying to match each node with the input flow, according to the principle of LL(n) parsing.

*Note:*

  This libray is not a parser generator (like bison ou antlr), but a tool to program an executable high-level grammar.
  So, there is no mecanism to find conflicts between branches : the analysis will stop at the first matching branch find within the grammar. So the order of writing alternatives (with the `|` operator) matters.
  In practical, writing ambiguous branches in the grammar is most of the times useless, as we prefer to group their prefix in a separate rule to write a grammar with a "one-token look-ahead".


Let's come back to the previous tree, and notice that its representation only supports BNF grammars, not EBNF ones. EBNF grammars extend BNF ones by the use of regular expression operators, such as thoses found in posix or perl regexp:
  * `*`: repeat the argument zero or more times
  * `+`: repeat one or more times
  * `!`: argument is optional

To represent these operators, a new tree format is needed:

{{{
              factor
                |
           Alternative
             /      \
      Aggregation    INTEGER
      /        \
     "("    Aggregation
           /          \
       expression     ")"
}}}

Complex operator `*` is represented by a binary node called `Repeat| which is parameterized by the minimum and maximum bound of this repetition (-1 as max bound means no limit).

{{{
        expression
            |
       Aggregation
      /          \
  term         Repeat<0, -1>
                    |
                Alternative
                 /       \
        Aggregation     Aggregation
          /     \         /      \
       '+'      term   '-'       term
}}}


Now, parsing an expression just consists in walking through the tree from root node and consuming tokens each time a primitive is matched.

Here below is the complete grammar translated into C++:

{{{
  factor = real
         | ch('(') >> expression >> ch(')')
         | (ch('-') >> factor)
         | (ch('+') >> factor);

  term = factor >> *( (ch('*') >> factor)
                    | (ch('/') >> factor)
                    | (ch('%') >> factor) );

  expression = term >> *( (ch('+') >> term)
                        | (ch('-') >> term) );
}}}

To keep the spirit of a BNF grammar, we jump to a new line on introducing an alternative with the `|` operator. We can also use parenthesis to avoid the use of an intermediate rule.

Notice that the use of the aggregation operator `>>` instead of just juxtaposing elements.

Now, we can add semantic actions. We do that with the `[]` operator. Such actions are executed only when the element on which they apply matches.

{{{
  factor = real [push] |
           ch('(') >> expression >> ch(')') |
           (ch('-') >> factor) [negate] |
           (ch('+') >> factor);

  term = factor >> *((ch('*') >> factor) [multiply] |
                     (ch('/') >> factor) [divide]);

  expression = term >> *((ch('+') >> term) [add] |
                         (ch('-') >> term) [substract]);
}}}

The full working exemple of this calculator is present in the repository at http://code.google.com/p/ell/source/browse/trunk/libELL/Test/Calc.h


=== Grammar primitives ===

Ell library provides a set of predefined primitives:

|| Primitive || Meaning ||
|| end                  || matches the end of the input ||
|| eps                  || always matches, never consumes ||
|| any                  || matches any input token (eos excepted) ||
|| ch(token)            || matches the given token ||
|| str(s)               || matches a string of input tokens ||
|| error(msg)           || unconditional parsing error generation with custom message ||

For character parsers (ie. when input tokens are C++ primitives like `char`, `int` or `wchar_t`), some specialized parser primitives are provided:

|| Primitive || Meaning ||
|| chset(arg)           || give a charset. Ex: `chset("A-Z_.-")` defines `[A-Z_.-]` ||
|| digit                || `[0-9]` ||
|| range<a, b>          || matches a character in the given range ||
|| lower                || `[a-z]` ||
|| upper                || `[A-Z]` ||
|| alpha                || `[a-zA-Z_]` ||
|| alnum                || `[a-zA-Z0-9_]` ||
|| blank                || `[ \t\n\r]` ||
|| ident                || `lexeme(alpha) >> * alnum)` ||
|| istr(s)              || matches the given string, ignoring case ||
|| visible_ascii        || `[!-~]` (visibles ASCII character) ||
|| utf8nonascii         || valid UTF-8 character outside the ASCII character set ||
|| signed_dec           || signed decimal integer ||
|| real                 || flotting point number (`strtod` format) ||
|| dec                  || decimal integer (`+ digit`) ||
|| hex                  || hexadecimal integer ||
|| oct                  || octal integer ||
|| bin                  || binary integer ||
|| kw(s)                || keyword (equivalent to `no_suffix(str(s), alnum)`) ||
|| ikw(s)               || case-insensitive keyword ||


=== Grammar operators ===

The tables below lists all the operators which can be used to write a grammar. Of course, you can use [http://www.cppreference.com/wiki/operator_precedence C++ operator precedence].

==== Binary operators ====

|| Name || Notation || Meaning ||
|| Sequence || `a >> b` || a followed by b ||
|| Choice || `a | b` || a or b ||
|| Exclusion || `a - b` || a bereft of b (match a but not b) ||
|| List (with separator) || `a % b` || one or more a separated by b (similar to `a >> * (b >> a)`) ||
|| Bound repetition || `a * b` || zero or more a until b (similar to `* (a - b) >> b` but much more efficient) ||
|| Combination || `a & b` || a followed or preceded by b (similar to `(a >> b) | (b >> a)`) ||
|| Longest || `a |``| b` || the longest of a or b (take a if equal). Avoid using it if you care in performance ||

==== Unary operators ====

|| Notation || Meaning ||
|| `! a` || Optional match ||
|| `+ a` || One or more repetition ||
|| `* a` || Zero or more repetition ||
|| `a [& Class::variable]` || Assign the result of matching into a variable. ||
|| `a [& Class::method]` || Call the given member function passing the matching result. ||

*Note:*

  Last two operators are called semantic operators. They have no effect if the rule on which they applied does not match. The variables or methods passed in argument must be members of the Parser class instance used for parsing.

  The types which are allowed for variables or method targetted by the semantic action depend on the node on which the action operator is applied. For example, the code below parses a list of space-separated unsigned integers, and assign them into a standard set of signed integers. The repetition operator (`+`) allows to target a STL container : without such a repetition, the compiler would issue an error when trying to resolve the `[ ]` operator:

{{{
struct MyParser : ell::Parser<char>, ell::Grammar<char>
{
    MyParser()
      : ell::Parser<char>(& rule, & blank)
    {
        rule = (+ dec) [& MyParser::list];
   
        parse("12 1 9");
    }
   
    ell::Rule<char> rule;
   
    std::set<int> list;
};
}}}

=== Grammar directives ===

In addition to primitives and operators, you can use the following methods in your grammar:

|| Notation || Meaning ||
|| `repeat<exact>(rule)` || Exact number of repetition ||
|| `repeat<min, max>(rule)` || Repetition within a range ||
|| `repeat(& Class::exact, rule)` || Exact repetition resolved at run-time ||
|| `repeat(& Class::min, &Class::max, rule)` || Range repetition resolved at run-time ||
|| `look_ahead(rule)` || Allow parser step back when searching for the first matching branch along `rule` ||
|| `no_look_ahead(rule)` || Issue an error when the right operand of an aggregation operataor mismatch, ie. walk along the grammar in a LL(1) manner ||
|| `no_action(rule)` || Disable all semantic actions (inhibate operator[]) ||
|| `no_consume(rule)` || Restore the position of the parser in the input token list after having parse along `rule` ||
|| `no_suffix(a, b)` || equivalent to `lexeme(a >> (eps - b))` ||
|| `lexeme(rule)` || Defines a new primitive by disabling skipper and allowing look-ahead inside `rule` ||

== How to write your grammars ==

=== Prevent branch conflicts ===

The idea between ELL is that simplicity is better that heavy-featuring.
Indeed, ELL library provides a straigth forward means to write LL(n) grammars, but there is no mecanism to detect conflicts between branch.

Writing a grammar with ELL library is no more than building up a tree along which the Parser will perform a depth-first search.

So, order does matter when writing a grammar. Consider the following (quite naÃ¯ve) exemple:

{{{
rule1 = str("foo") >> str("bar")
      | str("foo") >> str("t");
}}}

If you try to parse the word `foot`, the parser will first try to match the first branch of the `|`-alternative. The second primitive `str("bar")` won't match, so the parser will fall back on the second branch.

Keep in mind that each time a node of the grammar does not match, the cursor of the parser is restored back at the position where it was before try to match this node. So the definition above will produce a working parser for word `foot`, although rather inefficient.

A better way to write the grammar would be :

{{{
rule1 = str("foo") >> ( str("bar")
                      | str("t") );
}}}

This will prevent the parser from stepping-back to a token which has already been consumed.


=== Detect errors ealrier ===

Consider the following grammar:

{{{
root = brunch | diner;

brunch = str("bacon") >> str("eggs") >> str("beer");

diner = str("salad") >> str("cassoulet") >> str("kouign amann");
}}}


Now, let's parse a meal which does not match this grammar, for exemple `bacon eggs kouign amann`.

By default, the parser is LL(n), so both branches will be evaluated before issuing an error :



